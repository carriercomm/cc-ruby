#!/usr/bin/env ruby

require 'yaml'
require File.expand_path("../../lib/cloud-quartz", __FILE__)
require 'optparse'
require 'rubygems'
require 'socket'
require 'logger'
begin
	gem 'eventmachine', '~>1.0.0.beta.4'
	gem 'faye', '~>0.8.0'

	require 'eventmachine'
	require 'faye'
rescue LoadError => exc
	warn "Cannot find required ruby gems needed to run this agent. Please install cloudblocks gem by running 'gem install cloudblocks'"
	warn exc
	exit -1
end

@version = 1
str_version = "0.0.#{@version}"

config_file = 'cloudblocks.yaml'
@pid_file = 'quartz.pid'
@log_file = 'quartz.log'
@config_dir = File.join(Dir.home, '.cloudblocks')
@config_full = File.join(@config_dir, config_file)
@pid_full = File.join('/tmp', @pid_file)
@log_full = File.join('/tmp', @log_file)

@api_key = ''
@faye_url = 'https://socket.thecloudblocks.com:8443/'
commands = %w[register unregister start stop]

@plugins = {}

@url = nil
@daemon_mode = true
command = nil
@agent_id = nil
@realtime = true
OptionParser.new do |opts|
	opts.banner = 	<<-EOF
CloudQuartz Agent. v#{str_version} (c) 2012 CloudBlocks
For more information please visit http://www.thecloudblocks.com

Usage: quartz [register|unregister|start|stop] [options]

Options:
EOF

	opts.on('--url URL', 'Server URL') do |server_url|
		@url = server_url
	end
	@url = @url || 'https://api.thecloudblocks.com'

	opts.on('--agent-id AGENTID', 'Agent id') do |v|
		@agent_id = v
	end

	opts.on('-d', '--no-daemon', 'Not in daemon mode') do |v|
		@daemon_mode = false
	end

	opts.on('-p', '--pid PID', 'PID file path') do |v|
		@pid_full = v
	end

	opts.on('-l', '--log LOG', 'Log file path') do |v|
		@log_full = v
	end

	opts.on('-c', '--config CONFIG', 'Config file path') do |v|
		@config_full = v
	end

	opts.on('--sockets SOCKETS', 'Sockets URL') do |v|
		@faye_url = v
	end

	opts.on('--api-key APIKEY', 'API key') do |v|
		@api_key = v
	end

	opts.on('-n', '--no-realtime', 'Disable realtime notifications') do |v|
		@realtime = false
	end

	opts.on_tail("-h", "--help", "Show this message") do
		puts opts
		puts <<-EOF

Commands:
	register 			Register the agent
	start 				Starts agent as deamon
	stop 				Stops agent daemon
	unregister			Unregister the agent

		EOF
		exit 0
	end
end.parse!

command = ARGV[0].downcase unless ARGV[0].nil?

if @daemon_mode
	@log = Logger.new(@log_full)
else
	@log = Logger.new(STDOUT)
end

@log.level = Logger::DEBUG

if @api_key.empty? && File.exists?(@config_full)
	# config file present
	config = YAML::load(File.open(@config_full))
	@api_key = config['api_key']
	@agent_id = config['agent_id']
elsif @api_key.empty? && command != 'register'
	# no config file
	puts 'CloudBlocks CloudQuartz'
	puts 'Please enter your API key. (you can find it at https://www.thecloudblocks.com/me):'
	@api_key = gets
	@api_key = @api_key.chomp
	if @api_key.length != 32
		puts 'Invalid API key'
		exit -1
	else
		save_config
		puts 'Configuration Saved'
	end
end

if command.nil? || command.empty?
	puts 'No command found. Use --help for more information'
	exit -1
end

unless commands.include?(command)
	puts 'Invalid command. Use --help for more information'
	exit -1
end

if (@agent_id.nil? || @agent_id.empty?) && command != 'register'
	puts 'No Agent id found. Have you registered it yet? Use --help for more information'
	exit -1
end

@load_path = File.expand_path(File.join(File.dirname(__FILE__), '../lib/plugins'))

# commands
@quartz = CloudQuartz.new(:api_key => @api_key, :url => @url, :agent_id => @agent_id)

def start
	@log.info "Starting CloudQuartz agent"
	puts "Starting CloudQuartz agent"

	pid = get_pid
	if pid != 0
		warn "Quartz is already running. Use stop command to stop it or --help for more info"
		exit -1
	end

	check_version
	load_plugins

	@quartz.status(1, @version, plugin_meta_data)

	if @daemon_mode
		pid = fork {
			run
		}

		begin
			file = File.new(@pid_full, "w")
			file.write(pid)
			file.close
			Process.detach(pid)
		rescue => exc
			Process.kill('TERM', pid)
			warn "Cannot start CloudQuartz agent: #{exc.message}"
		end
	else
		run
	end
end

def stop
	pid = get_pid
	@log.info "Stopping CloudQuartz agent"
	begin
		@quartz.status(2, @version, plugin_meta_data)
		EM.stop
	rescue
	end

	if pid != 0
		Process.kill('HUP', pid.to_i)
		File.delete(@pid_full)
		puts "Stopped"
	else
		warn "Quartz is not running"
		exit -1
	end
end

def register
	puts "Registering agent with #{@url} and API Key #{@api_key}"
	os_name = RUBY_PLATFORM
	os_id = os_name.include?('darwin') ? 5 : 1
	agent = { :agent_type_id => os_id, :agent_name => Socket.gethostname, :agent_timezone => Time.new.zone, :extra => os_name}

	result = @quartz.register(agent)
	if result['ok']
		@agent_id = result['uid']
		puts "Registered with id #{@agent_id}"
		save_config
	else
		puts "Failed to register due to #{result['error']}"
		exit -1
	end
end

def unregister
	puts "Unregister agent #{@agent_id} with #{@url}"
	@agent_id = ""
	@quartz.unregister(@agent_id)
	save_config
end

private

def load_plugins
	@log.info "Loading plugins from #{@load_path}"

	files = Dir.glob("#{@load_path}/*.rb")
	files.each do |file|
		if file != 'quartz_plugin'
			# is it a valid plugin?
			require "#{file}"
			classname = File.basename(file, '.rb').capitalize
			begin
				clazz = Kernel.const_get(classname)
				if clazz.ancestors[1].name == 'QuartzPlugin'
					instance = clazz.new(@log, { :api_key => @api_key, :agent_id => @agent_id })
					guid = instance.info[:uid]
					@plugins = @plugins.merge({ guid => instance })
					@log.info "Found plugin #{instance.info[:name]}/#{instance.info[:version]} with uid #{guid}"
				end
			rescue
			end
		end
	end

	@log.debug "All plugins #{plugin_meta_data}"
end

def plugin_meta_data
	result = []
	@plugins.each do |k, v|
		result << v.info
	end

	result
end

def get_job
	result = @quartz.get_job
	if result['ok']
		if result['empty']
			@log.debug 'No jobs to run'
		else
			message = JSON.parse(result['message'])
			guid = message['plugin_uid']
			name = message['template_name']
			drt = message['desired_run_time']

			@log.info "Going to run #{name} (uid:#{guid})"

			# get the plugin
			if @plugins.include?(guid)
				plugin = @plugins[guid]
				# run it
				fork { run_plugin(plugin, message) }
			else
				@log.error "No plugin found with uid #{guid}"
				# TODO: Send this back to server as run error
			end
		end
	else
		@log.error "Failed to retrieve job due to #{result['error']}"
	end
end

def save_config
	if !FileTest::directory?(@config_dir)
		Dir.mkdir(@config_dir)
	end
	File.open(@config_full, 'w+') { |out| YAML::dump({ 'api_key' => @api_key, 'agent_id' => @agent_id }, out) }
end

def run_plugin(plugin, message)
	run_start = Time.now.utc.to_i
	begin
		job_id = message['job_id']
		@log.debug "Running #{plugin.info[:guid]} with #{message}"
		result = plugin.run(message)
		@log.debug "Run returned for job #{job_id} with #{result}"
		@log.debug result
		ok = result[:ok]
		to_return = result[:message]
	rescue => exc
		@log.error "Failure during running plugin #{plugin} due to #{exc}"
		ok = false
		if result.nil?
			to_return = exc.message
		else
			to_return = result[:message] 
		end
	ensure
		data = { :run_start => run_start, :run_end => Time.now.utc.to_i, :agent_uid => @agent_id, :ok => ok }
		data = ok ? data.merge({ :run_result => to_return }) : data.merge({ :fail_reason => to_return })
		begin
			@log.debug "Posting results for job #{job_id} back to the server #{data}"
			@quartz.post_results(job_id, data)
		rescue => e
			@log.error "Failed to post results back to server due to #{e}"
		end
	end
end

def check_version
	begin
		result = @quartz.check_version
		if result['ok']
			latest = result['latest']
			@log.warn 'A newer version of CloudQuartz agent is available. Update the cloudblocks gem. See http://help.thecloudblocks.com for more info' if latest > @version
		end
	rescue => exc
		warn "Cannot connect to the server"
		exit -1
	end
end

private 

def run
	EM.run{
	 	Signal.trap('INT') { stop }
	    Signal.trap('TERM'){ stop }

	    if @realtime
	    	@log.info "Listening to realtime nofitifications from /quartz/jobs/#{@agent_id} on #{@faye_url}" 
	    	client = Faye::Client.new(@faye_url)
			client.subscribe("/quartz/jobs/#{@agent_id}") do |message|
    			@log.info "Got realtime notice for a new job #{message}"
    			get_job
			end
	    else
	    	@log.info "Checking for new jobs every 5 seconds"
			EM.add_periodic_timer 5 do
				get_job
			end
		end
	}
end

def get_pid
	if File.exists?(@pid_full)
		file = File.new(@pid_full, "r")
		pid = file.read
		file.close

		pid
	else
		0
	end
end

public

send(command)
