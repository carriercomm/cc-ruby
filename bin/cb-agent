#!/usr/bin/env ruby

require 'yaml'
require File.expand_path("../../lib/cloud-quartz", __FILE__)
require 'optparse'
require 'socket'
require 'logger'
require 'highline/import'
begin
	gem 'eventmachine', '~>1.0.0.beta.4'
	gem 'faye', '~>0.8.0'
	gem 'highline', '~>1.6.11'

	require 'eventmachine'
	require 'faye'
rescue LoadError => exc
	warn "Cannot find required ruby gems needed to run this agent. Please install cloudblocks gem by running 'gem install cloudblocks'"
	warn exc
	exit -1
end

private

def save_config
	if !FileTest::directory?(@config_dir)
		Dir.mkdir(@config_dir)
	end
	File.open(@config_full, 'w+') { |out| YAML::dump({ 'api_key' => @api_key, 'agent_id' => @agent_id, 'secret_key' => @secret_key }, out) }
end

public

@load_path = File.expand_path(File.join(File.dirname(__FILE__), '../lib/plugins'))

def start
	begin
		@log.info "Attempting to start the CloudBlocks Agent"
		puts "Attempting to start the CloudBlocks Agent..."

		pid = get_pid
		if pid != 0
			#check if the process is actually running
			if pid_process_running?(pid)
				warn "The CloudBlocks Agent was already running. Use stop command to stop it or --help for more info"
				exit -1
			else
				File.delete(@pid_full)
			end
		end

		check_version
		load_plugins
	rescue => exc
		@log.error exc.message
		exit -1
	end

	begin
		@log.info @quartz.init(@version, plugin_meta_data)
	rescue Exception => e
		message = e.message
		if message =~ /Couldn't find Agent with uid =/
			@log.warn "This agent is no longer registered at the server. The old registration details have been removed from this agent. Please re-run the agent to re-register it."
			puts "This agent is no longer registered at the server. The old registration details have been removed from this agent. Please re-run the agent to re-register it."
			puts @config_full
			File.delete(@config_full)
		else
			@log.error e.message
		end
		exit -1
	end

	if @daemon_mode
		pid = fork {
			run
		}

		begin
			file = File.new(@pid_full, "w")
			file.write(pid)
			file.close
			Process.detach(pid)
		rescue => exc
			Process.kill('TERM', pid)
			warn "Cannot start the CloudBlocks Agent: #{exc.message}"
		end

		puts "The CloudBlocks Agent has been started!"
	else
		run
	end


	exit 0
end

def stop
	pid = get_pid
	@log.info "Attempting to stop the CloudBlocks Agent"
	puts "Attempting to stop the CloudBlocks Agent..."

	begin		
		@quartz.status(2)
		EM.stop		
	rescue
	end

	if pid != 0
		begin
			Process.kill('HUP', pid.to_i)
		rescue
		end
		File.delete(@pid_full)
		puts "The CloudBlocks Agent has been stopped!"
	else
		warn "Nothing to do - the CloudBlocks Agent was not running"
		exit -1
	end
end

def register
	puts "Registering the CloudBlocks Agent with #{@url} and API Key #{@api_key}..."
	os_name = RUBY_PLATFORM
	os_id = os_name.include?('darwin') ? 5 : 1
	agent = { :agent_type_id => os_id, :agent_name => Socket.gethostname, :agent_timezone => Time.new.zone, :extra => os_name}

	result = @quartz.register(agent)
	if result['ok']
		@agent_id = result['uid']
		puts "Registered with id #{@agent_id}"
		save_config
	else
		puts "Failed to register due to #{result['error']}"
		exit -1
	end
end

def unregister
	puts "Unregistering the CloudBlocks Agent #{@agent_id} with #{@url}..."
	@agent_id = ""
	@quartz.unregister(@agent_id)
	save_config
	puts "Unregistered successfully!"
end

private

def load_plugins
	@log.info "Loading plugins from #{@load_path}"

	files = Dir.glob("#{@load_path}/*.rb")
	files.each do |file|
		unless file =~ /quartz_plugin/

			# is it a valid plugin?
			require "#{file}"
			classname = File.basename(file, '.rb').split('_').collect{ |part| part.capitalize }.join
			begin
				clazz = Kernel.const_get(classname)
				if clazz.ancestors[1].name == 'QuartzPlugin'
					instance = clazz.new(@log, { :api_key => @api_key, :agent_id => @agent_id })
					guid = instance.info[:uid]
					@plugins = @plugins.merge({ guid => instance })
					@log.info "Found plugin #{instance.info[:name]}/#{instance.info[:version]} with uid #{guid}"
				else
					@log.error "Invalid plugin found #{clazz}"
				end
			rescue 
			end
		end
	end

	@log.debug "All plugins #{plugin_meta_data}"
end

def plugin_meta_data
	result = []
	@plugins.each do |k, v|
		result << v.info
	end

	result
end

def get_job
	begin
		result = @quartz.get_job
		if result['ok']
			if result['empty']
				@log.debug 'No jobs to run'
			else
				message = JSON.parse(result['message'])
				guid = message['plugin_uid']
				name = message['template_name']
				drt = message['desired_run_time']

				@log.info "Going to run #{name} (uid:#{guid})"

				# get the plugin
				if @plugins.include?(guid)
					plugin = @plugins[guid]
					# run it
					operation = proc { run_plugin(plugin, message) }
					EM.defer(operation)
				else
					@log.error "No plugin found with uid #{guid}"
					job_id = message['job_id']
					data = { :run_start => Time.now.utc.to_i, :run_end => Time.now.utc.to_i, :agent_uid => @agent_id, :ok => false, :fail_reason => "Requested plugin not found. Does this agent support this job type?" }
					@quartz.post_results(job_id, data)
				end
			end
		else
			@log.error "Failed to retrieve job due to #{result['error']}"
		end
	rescue => exc
		@log.error "Failed to retrieve job due to #{exc}"
	end
end

def run_plugin(plugin, message)
	run_start = Time.now.utc.to_i
	begin
		job_id = message['job_id']
		result = plugin.run(message)
		@log.debug "Run returned for job #{job_id} with #{result}"
		@log.debug result
		ok = result[:ok]
		to_return = result[:message]
	rescue => exc
		@log.error "Failure during running plugin #{plugin} due to #{exc}"
		ok = false
		if result.nil?
			to_return = exc.message
		else
			to_return = result[:message] 
		end
	ensure
		data = { :run_start => run_start, :run_end => Time.now.utc.to_i, :agent_uid => @agent_id, :ok => ok }
		data = ok ? data.merge({ :run_result => to_return }) : data.merge({ :fail_reason => to_return })
		begin
			@log.debug "Posting results for job #{job_id} back to the server #{data}"
			@quartz.post_results(job_id, data)
		rescue => e
			@log.error "Failed to post results back to server due to #{e}"
		end
	end
end

def check_version
	begin
		result = @quartz.check_version
		if result['ok']
			latest = result['latest']
			@log.warn 'A newer version of the CloudBlocks Agent is available. Please update the cloudblocks gem. See http://help.cloudblocks.co for more info' if latest > @version
		end
	rescue => exc
		warn "Cannot connect to the CloudBlocks server"
		exit -1
	end
end

def pulsate
	@log.debug "Pulsate"
	begin
		@quartz.pulse 
	rescue => exc
		@log.error "Failed to pulsate due to #{exc.message}"
	end
end

def run
	EM.run{
		Signal.trap('INT') { stop }
		Signal.trap('TERM'){ stop }

	    # pulse
	    pulsate
		EM.add_periodic_timer 60 do  # 1 minute
			pulsate
		end

		if @realtime
			@log.info "Listening to realtime nofitifications from /quartz/agents/#{@agent_id} on #{@faye_url}" 
			client = Faye::Client.new(@faye_url)
			client.subscribe("/quartz/agents/#{@agent_id}") do |message|
				@log.info "Got realtime notice for a new job #{message}"
				get_job
			end
		else
			@log.info "Checking for new jobs every 5 seconds"
			EM.add_periodic_timer 5 do
				get_job
			end
		end
	}
end

def get_pid
	if File.exists?(@pid_full)
		file = File.new(@pid_full, "r")
		pid = file.read
		file.close
		pid
	else
		0
	end
end

def pid_process_running?(pid)
	begin
		pid_number = pid.to_i
		Process.getpgid(pid_number)
		true
	rescue Errno::ESRCH
		false
	end
end

public

@version = 1
str_version = "0.0.#{@version}"

config_file = 'cloudblocks.yaml'
@pid_file = 'cb-agent.pid'
@log_file = 'cb-agent.log'
@config_dir = File.join(File.expand_path('~'), '.cloudblocks')
@config_full = File.join(@config_dir, config_file)

@cb_tmp_dir = '/tmp/cloudblocks'
Dir.mkdir(@cb_tmp_dir) if !File.exists?(@cb_tmp_dir)

@pid_full = File.join(@cb_tmp_dir, @pid_file)
@log_full = File.join(@cb_tmp_dir, @log_file)

@api_key = ''
@faye_url = 'https://sockets.cloudblocks.co/push/'
commands = %w[register unregister start stop]

@plugins = {}

@url = nil
@daemon_mode = true
command = nil
@agent_id = ''
@realtime = true
OptionParser.new do |opts|
	opts.banner = 	<<-EOF
	CloudBlocks Agent. v#{str_version} (c) 2012 CloudBlocks
	For more information please visit http://cloudblocks.co

	Usage: cb-agent [register|unregister|start|stop] [options]

	Options:
	EOF

	opts.on('--url URL', 'Server URL') do |server_url|
		@url = server_url
	end
	@url = @url || 'https://api.cloudblocks.co'

	opts.on('--agent-id AGENTID', 'Agent id') do |v|
		@agent_id = v
	end

	opts.on('-d', '--no-daemon', 'Not in daemon mode') do |v|
		@daemon_mode = false
	end

	opts.on('-p', '--pid PID', 'PID file path') do |v|
		@pid_full = v
	end

	opts.on('-l', '--log LOG', 'Full log file path') do |v|
		@log_full = v
	end

	opts.on('-c', '--config CONFIG', 'Config file path') do |v|
		@config_full = v
	end

	opts.on('--sockets SOCKETS', 'Sockets URL') do |v|
		@faye_url = v
		@faye_url = "#{@faye_url}/" if @faye_url[-1] != '/'
	end

	opts.on('--api-key APIKEY', 'API key') do |v|
		@api_key = v
	end

	opts.on('--secret-key SECRETKET', 'Secret Key') do |v|
		@secret_key = v
	end

	opts.on('-r', '--realtime', 'Enable realtime notifications (default)') do |v|
		@realtime = true
	end

	opts.on('-R', '--no-realtime', 'Disable realtime notifications') do |v|
		@realtime = false
	end

	opts.on_tail("-h", "--help", "Show this message") do
		puts opts
		puts <<-EOF

		Commands:
		register 			Register the CloudBlocks Agent
		start 				Starts the CloudBlocks Agent as a deamon
		stop 				Stops the CloudBlocks Agent daemon
		unregister			Unregisters the CloudBlocks Agent

		EOF
		exit 0
	end
end.parse!

command = ARGV[0].downcase unless ARGV[0].nil?

if @daemon_mode
	@log = Logger.new(@log_full)
else
	@log = Logger.new(STDOUT)
end

@log.level = Logger::DEBUG

if (@api_key.empty? || @agent_id.empty?) && File.exists?(@config_full)
	# config file present
	config = YAML::load(File.open(@config_full))
	@api_key = config['api_key']
	@agent_id = config['agent_id']
	@secret_key = config['secret_key']
end

# still no api key, we need to get it
if @api_key.empty?
	puts 'CloudBlocks Agent initial setup:'
	@api_key = ask('Please enter your API key. (you can find it at https://cloudblocks.co/me): ')
	if @api_key.length != 32
		puts 'Invalid API key'
		exit -1
	end

	@secret_key = ask('Please enter your Secret Key (you can find it at https://cloudblocks.co/me): ')
	if @secret_key.length != 32
		puts 'Invalid Secret key'
		exit -1
	end
end

# no agent id?
if @agent_id.empty?
	@quartz = CloudQuartz.new(:api_key => @api_key, :url => @url, :secret_key => @secret_key)
	register 
	@quartz = CloudQuartz.new(:api_key => @api_key, :url => @url, :agent_id => @agent_id, :secret_key => @secret_key)
	start
end

if command.nil? || command.empty?
	pid = get_pid
	#check if the process is actually running
	if pid != 0 && pid_process_running?(pid)
		puts "The CloudBlocks Agent is currently running. Use 'cb-agent stop' to stop it or --help for more info"
		exit -1
	end
	puts "The CloudBlocks Agent is not currently running. Use 'cb-agent start' to start it or --help for more information"
	exit -1
end

unless commands.include?(command)
	puts 'Invalid command. Use --help for more information'
	exit -1
end

if (@agent_id.nil? || @agent_id.empty? || @agent_id.empty? || @secret_key.empty?) && command != 'register'
	puts 'No CloudBlocks Agent id found. Have you registered it yet? Use --help for more information'
	exit -1
end

@quartz = CloudQuartz.new(:api_key => @api_key, :url => @url, :agent_id => @agent_id, :secret_key => @secret_key)

send(command)
